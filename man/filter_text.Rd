% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/nlp.R
\name{filter_text}
\alias{filter_text}
\title{텍스트 데이터의 문자열 매치 데이터 필터링}
\usage{
filter_text(
  doc,
  chunk = round(length(if (tibble::is_tibble(doc)) dplyr::pull(doc) else doc)/mc.cores),
  mc.cores = parallel::detectCores(),
  verbos = TRUE
)
}
\arguments{
\item{doc}{character. 문자열 필터링을 수행할 문자열 벡터}

\item{chunk}{integer. 병렬 작업 수행 시 처리 단위인 chunk}

\item{mc.cores}{integer. 병렬 작업 수행 시 사용할 코어의 개수}

\item{verbos}{logical. 메타의 Rule 당 처리된 건수를 화면에 출력할 지의 여부}
}
\value{
character. 문자열 필터링이 수행된 문자열 벡터.
}
\description{
텍스트 데이터의 전처리 과정 중 패턴 일치되는 문자열이 있는
데이터를 취하거나 제거한다.
}
\examples{
\dontrun{
##======================================================
## 문자열 매치 데이터 필터링
##======================================================

# 매치 데이터 필터링 메타 신규 등록
meta_path <- system.file("meta", package = "bitTA")
fname <- glue::glue("{meta_path}/preparation_filter.csv")
set_meta("filter", fname, fileEncoding = "utf8")

# 등록된 필터링 룰 확인하기
get_meta("filter")

doc_content <- buzz[, "CONTENT"]

# 필터링, verbos = FALSE, chunk = 200
doc_content_after <- filter_text(doc_content, verbos = FALSE, chunk = 200)

# 필터링, chunk = 500, mc.cores = 8
doc_content_after <- filter_text(doc_content, chunk = 500, mc.cores = 8)

# 필터링 전/후 비교
NROW(doc_content)
length(doc_content_after)
}

}
